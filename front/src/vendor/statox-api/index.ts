/**
 * AUTO-GENERATED SDK for api.statox.fr
 * Generated on: 2025-11-19T21:24:20.586Z
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Run: npm run generate:sdk
 */

import Ajv, { type ValidateFunction } from 'ajv';
import type { FromSchema } from 'json-schema-to-ts';

// Schemas
export const schemas = {
  "auth_login_Input": {
    "type": "object",
    "required": [
      "username",
      "password"
    ],
    "additionalProperties": false,
    "properties": {
      "username": {
        "type": "string"
      },
      "password": {
        "type": "string"
      }
    }
  },
  "auth_login_Output": {
    "type": "object",
    "properties": {},
    "required": [],
    "additionalProperties": false
  },
  "auth_logout_Input": {
    "type": "object",
    "required": [],
    "additionalProperties": false,
    "properties": {}
  },
  "auth_logout_Output": {
    "type": "object",
    "properties": {},
    "required": [],
    "additionalProperties": false
  },
  "auth_me_Input": {
    "type": "object",
    "required": [],
    "additionalProperties": false,
    "properties": {}
  },
  "auth_me_Output": {
    "oneOf": [
      {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "logged_out"
            ]
          }
        },
        "required": [
          "status"
        ],
        "additionalProperties": false
      },
      {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "logged_in"
            ]
          },
          "user": {
            "type": "object",
            "properties": {
              "id": {
                "type": "number"
              },
              "username": {
                "type": "string"
              },
              "scopes": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "admin",
                    "public",
                    "homeTracker"
                  ]
                }
              }
            },
            "required": [
              "id",
              "username",
              "scopes"
            ],
            "additionalProperties": false
          }
        },
        "required": [
          "status",
          "user"
        ],
        "additionalProperties": false
      }
    ]
  },
  "chords_addLinkVisit_Input": {
    "type": "object",
    "required": [
      "url"
    ],
    "additionalProperties": false,
    "properties": {
      "url": {
        "type": "string"
      }
    }
  },
  "chords_addLinkVisit_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "chords_checkLinks_Output": {
    "type": "object",
    "properties": {
      "nbChecks": {
        "type": "number"
      },
      "nbSkipped": {
        "type": "number"
      },
      "nbFails": {
        "type": "number"
      },
      "timestamp": {
        "type": "number"
      },
      "fails": {
        "type": "array",
        "minItems": 0,
        "items": {
          "type": "object",
          "properties": {
            "status": {
              "type": "string"
            },
            "chord": {
              "type": "object",
              "properties": {
                "artist": {
                  "type": "string"
                },
                "title": {
                  "type": "string"
                },
                "url": {
                  "type": "string"
                },
                "creationDate": {
                  "type": "number"
                },
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "required": [
                "artist",
                "title",
                "url",
                "creationDate",
                "tags"
              ],
              "additionalProperties": false
            },
            "error": {
              "type": "object"
            }
          },
          "required": [
            "status",
            "chord"
          ],
          "additionalProperties": false
        }
      }
    },
    "required": [
      "nbChecks",
      "nbSkipped",
      "nbFails",
      "timestamp",
      "fails"
    ],
    "additionalProperties": false
  },
  "chords_getAll_Output": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "artist": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "creationDate": {
          "type": "number"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "artist",
        "title",
        "url",
        "creationDate",
        "tags"
      ]
    }
  },
  "chords_getLinksVisitsCount_Output": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string"
        },
        "count": {
          "type": "number"
        },
        "lastAccessDateUnix": {
          "type": "number"
        }
      },
      "required": [
        "url",
        "count",
        "lastAccessDateUnix"
      ],
      "additionalProperties": false
    }
  },
  "chords_updateAll_Input": {
    "type": "object",
    "required": [
      "chords"
    ],
    "additionalProperties": false,
    "properties": {
      "chords": {
        "type": "array",
        "items": {
          "type": "object",
          "required": [
            "artist",
            "title",
            "url",
            "creationDate",
            "tags"
          ],
          "additionalProperties": false,
          "properties": {
            "artist": {
              "type": "string",
              "minLength": 1
            },
            "title": {
              "type": "string",
              "minLength": 1
            },
            "url": {
              "type": "string",
              "minLength": 1
            },
            "creationDate": {
              "oneOf": [
                {
                  "type": "number",
                  "minimum": 1600000000000
                },
                {
                  "type": "number",
                  "enum": [
                    0
                  ]
                }
              ]
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      }
    }
  },
  "chords_updateAll_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "clipboard_addEntry_Input": {
    "type": "object",
    "required": [
      "name"
    ],
    "additionalProperties": false,
    "properties": {
      "name": {
        "type": "string"
      },
      "content": {
        "type": "string"
      },
      "file": {
        "type": "array"
      },
      "ttlSeconds": {
        "type": [
          "number",
          "string"
        ],
        "minimum": 0
      },
      "isPublic": {
        "type": [
          "boolean",
          "string"
        ]
      }
    }
  },
  "clipboard_addEntry_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "clipboard_deleteEntry_Input": {
    "type": "object",
    "required": [
      "name"
    ],
    "additionalProperties": false,
    "properties": {
      "name": {
        "type": "string"
      }
    }
  },
  "clipboard_deleteEntry_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "clipboard_getAllEntries_Output": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "id": {
          "type": "number"
        },
        "name": {
          "type": "string"
        },
        "content": {
          "type": "string"
        },
        "creationDateUnix": {
          "type": "number"
        },
        "ttl": {
          "type": "number"
        },
        "isPublic": {
          "type": "boolean"
        },
        "linkId": {
          "type": "string"
        },
        "s3Key": {
          "type": [
            "string"
          ]
        },
        "s3PresignedUrl": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "content",
        "creationDateUnix",
        "ttl",
        "isPublic",
        "linkId"
      ],
      "additionalProperties": false
    }
  },
  "clipboard_getPublicEntries_Output": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "id": {
          "type": "number"
        },
        "name": {
          "type": "string"
        },
        "content": {
          "type": "string"
        },
        "creationDateUnix": {
          "type": "number"
        },
        "ttl": {
          "type": "number"
        },
        "isPublic": {
          "type": "boolean"
        },
        "linkId": {
          "type": "string"
        },
        "s3Key": {
          "type": "string"
        },
        "s3PresignedUrl": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "content",
        "creationDateUnix",
        "ttl",
        "isPublic",
        "linkId"
      ],
      "additionalProperties": false
    }
  },
  "clipboard_view_Output": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "id": {
          "type": "number"
        },
        "name": {
          "type": "string"
        },
        "content": {
          "type": "string"
        },
        "creationDateUnix": {
          "type": "number"
        },
        "ttl": {
          "type": "number"
        },
        "isPublic": {
          "type": "boolean"
        },
        "linkId": {
          "type": "string"
        },
        "s3Key": {
          "type": [
            "string",
            "null"
          ]
        },
        "s3PresignedUrl": {
          "type": "string"
        },
        "contentIsLink": {
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "name",
        "content",
        "creationDateUnix",
        "ttl",
        "isPublic",
        "linkId"
      ],
      "additionalProperties": false
    }
  },
  "cookbook_addRecipe_Input": {
    "type": "object",
    "required": [
      "name",
      "content",
      "ingredients"
    ],
    "additionalProperties": false,
    "properties": {
      "name": {
        "type": "string"
      },
      "content": {
        "type": "string"
      },
      "ingredients": {
        "type": "array",
        "items": {
          "type": "object",
          "required": [
            "name"
          ],
          "additionalProperties": false,
          "properties": {
            "name": {
              "type": "string"
            },
            "quantity": {
              "type": "number"
            },
            "unit": {
              "type": "string"
            }
          }
        }
      }
    }
  },
  "cookbook_addRecipe_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "cookbook_getRecipe_Input": {
    "type": "object",
    "required": [
      "recipeId"
    ],
    "additionalProperties": false,
    "properties": {
      "recipeId": {
        "type": "number"
      }
    }
  },
  "cookbook_getRecipe_Output": {
    "type": "object",
    "required": [
      "id",
      "name",
      "creationDateUnix",
      "updateDateUnix",
      "content",
      "ingredients"
    ],
    "additionalProperties": false,
    "properties": {
      "id": {
        "type": "number"
      },
      "name": {
        "type": "string"
      },
      "creationDateUnix": {
        "type": "number"
      },
      "updateDateUnix": {
        "type": "number"
      },
      "content": {
        "type": "string"
      },
      "ingredients": {
        "type": "array",
        "items": {
          "type": "object",
          "required": [
            "id",
            "name"
          ],
          "additionalProperties": false,
          "properties": {
            "id": {
              "type": "number"
            },
            "name": {
              "type": "string"
            },
            "quantity": {
              "type": [
                "number",
                "null"
              ]
            },
            "unit": {
              "type": [
                "string",
                "null"
              ]
            }
          }
        }
      }
    }
  },
  "cookbook_listIngredients_Output": {
    "type": "object",
    "properties": {
      "ingredients": {
        "type": "array",
        "minItems": 0,
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "id",
            "name"
          ],
          "additionalProperties": false
        }
      }
    },
    "required": [
      "ingredients"
    ],
    "additionalProperties": false
  },
  "cookbook_listRecipes_Output": {
    "type": "object",
    "properties": {
      "recipes": {
        "type": "array",
        "minItems": 0,
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number"
            },
            "name": {
              "type": "string"
            },
            "creationDateUnix": {
              "type": "number"
            },
            "updateDateUnix": {
              "type": "number"
            }
          },
          "required": [
            "id",
            "name",
            "creationDateUnix",
            "updateDateUnix"
          ],
          "additionalProperties": false
        }
      }
    },
    "required": [
      "recipes"
    ],
    "additionalProperties": false
  },
  "gravitrips_getNewGame_Output": {
    "type": "object",
    "properties": {
      "gameId": {
        "type": "string"
      }
    }
  },
  "health_getRemoteTime_Output": {
    "type": "number"
  },
  "homeTracker_getEphemerides_Output": {
    "type": "object",
    "properties": {
      "ephemerides": {
        "type": "object",
        "properties": {
          "moonState": {
            "type": "object",
            "properties": {
              "lunarAge": {
                "type": "number"
              },
              "lunarAgePercent": {
                "type": "number"
              },
              "moonPhase": {
                "type": "string"
              },
              "moonPhaseFr": {
                "type": "string"
              },
              "moonVisibilityWindow": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "maxItems": 2,
                "minItems": 2
              }
            },
            "required": [
              "lunarAge",
              "lunarAgePercent",
              "moonPhase",
              "moonPhaseFr",
              "moonVisibilityWindow"
            ],
            "additionalProperties": false
          },
          "sunState": {
            "type": "object",
            "properties": {
              "sunrise": {
                "type": "number"
              },
              "sunset": {
                "type": "number"
              },
              "solarNoon": {
                "type": "number"
              },
              "goldenHour": {
                "type": "number"
              },
              "dayLengthMs": {
                "type": "number",
                "description": "How many hours of sun this day (in ms)"
              },
              "dayLengthDiffMs": {
                "type": "number",
                "description": "The difference of day length compared to yesterday (in ms)"
              }
            },
            "required": [
              "sunrise",
              "sunset",
              "solarNoon",
              "goldenHour"
            ],
            "additionalProperties": false
          },
          "upcomingLunarStates": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "lunarState": {
                  "type": "object",
                  "properties": {
                    "lunarAge": {
                      "type": "number"
                    },
                    "lunarAgePercent": {
                      "type": "number"
                    },
                    "moonPhase": {
                      "type": "string"
                    },
                    "moonPhaseFr": {
                      "type": "string"
                    },
                    "moonVisibilityWindow": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "maxItems": 2,
                      "minItems": 2
                    }
                  },
                  "required": [
                    "lunarAge",
                    "lunarAgePercent",
                    "moonPhase",
                    "moonPhaseFr",
                    "moonVisibilityWindow"
                  ],
                  "additionalProperties": false
                },
                "tsMillis": {
                  "type": "number"
                }
              },
              "required": [
                "tsMillis",
                "lunarState"
              ]
            }
          }
        },
        "required": [
          "moonState",
          "sunState",
          "upcomingLunarStates"
        ],
        "additionalProperties": false
      }
    },
    "required": [
      "ephemerides"
    ],
    "additionalProperties": false
  },
  "homeTracker_getSensorsDataForDashboard_Output": {
    "type": "object",
    "properties": {
      "sensors": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "sensorName": {
              "type": "string"
            },
            "lastAlertDateUnix": {
              "type": [
                "number",
                "null"
              ]
            },
            "lastSyncDateUnix": {
              "type": "number"
            },
            "hexColor": {
              "type": "string",
              "description": "RGB color in hex format. Example: #AA33CC",
              "pattern": "^#[A-F0-9]{6}$"
            },
            "lastLogData": {
              "type": "object",
              "properties": {
                "timestamp": {
                  "type": "number"
                },
                "sensorName": {
                  "type": "string"
                },
                "batteryCharge": {
                  "type": "number"
                },
                "batteryPercent": {
                  "type": "number"
                },
                "detectedForcedReset": {
                  "type": "boolean"
                },
                "detectedInternalSensorFailure": {
                  "type": "boolean"
                },
                "detectedLowBattery": {
                  "type": "boolean"
                },
                "detectedSensorFailure": {
                  "type": "boolean"
                },
                "humidity": {
                  "type": "number"
                },
                "internalHumidity": {
                  "type": "number"
                },
                "internalTempCelsius": {
                  "type": "number"
                },
                "pressurehPa": {
                  "type": "number"
                },
                "tempCelsius": {
                  "type": "number"
                },
                "timeToSendMs": {
                  "type": "number"
                }
              },
              "required": [
                "sensorName",
                "timestamp"
              ],
              "additionalProperties": false
            },
            "oneHourAgoLogData": {
              "type": "object",
              "properties": {
                "timestamp": {
                  "type": "number"
                },
                "sensorName": {
                  "type": "string"
                },
                "batteryCharge": {
                  "type": "number"
                },
                "batteryPercent": {
                  "type": "number"
                },
                "detectedForcedReset": {
                  "type": "boolean"
                },
                "detectedInternalSensorFailure": {
                  "type": "boolean"
                },
                "detectedLowBattery": {
                  "type": "boolean"
                },
                "detectedSensorFailure": {
                  "type": "boolean"
                },
                "humidity": {
                  "type": "number"
                },
                "internalHumidity": {
                  "type": "number"
                },
                "internalTempCelsius": {
                  "type": "number"
                },
                "pressurehPa": {
                  "type": "number"
                },
                "tempCelsius": {
                  "type": "number"
                },
                "timeToSendMs": {
                  "type": "number"
                }
              },
              "required": [
                "sensorName",
                "timestamp"
              ],
              "additionalProperties": false
            },
            "oneDayAgoLogData": {
              "type": "object",
              "properties": {
                "timestamp": {
                  "type": "number"
                },
                "sensorName": {
                  "type": "string"
                },
                "batteryCharge": {
                  "type": "number"
                },
                "batteryPercent": {
                  "type": "number"
                },
                "detectedForcedReset": {
                  "type": "boolean"
                },
                "detectedInternalSensorFailure": {
                  "type": "boolean"
                },
                "detectedLowBattery": {
                  "type": "boolean"
                },
                "detectedSensorFailure": {
                  "type": "boolean"
                },
                "humidity": {
                  "type": "number"
                },
                "internalHumidity": {
                  "type": "number"
                },
                "internalTempCelsius": {
                  "type": "number"
                },
                "pressurehPa": {
                  "type": "number"
                },
                "tempCelsius": {
                  "type": "number"
                },
                "timeToSendMs": {
                  "type": "number"
                }
              },
              "required": [
                "sensorName",
                "timestamp"
              ],
              "additionalProperties": false
            },
            "sleepTimeSec": {
              "type": "number"
            },
            "tempOffset": {
              "type": "number"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "required": [
      "sensors"
    ],
    "additionalProperties": false
  },
  "homeTracker_getWeatherForecast_Output": {
    "type": "object",
    "properties": {
      "forecast": {
        "type": "object",
        "properties": {
          "pressureTrend": {
            "type": "string",
            "enum": [
              "falling",
              "rising",
              "steady",
              "unknown"
            ]
          },
          "forecast": {
            "type": "string"
          },
          "dataPoints": {
            "type": "object",
            "properties": {
              "latest": {
                "type": "object",
                "properties": {
                  "pressurehPa": {
                    "type": "number"
                  },
                  "timestampMs": {
                    "type": "number"
                  }
                },
                "required": [
                  "pressurehPa",
                  "timestampMs"
                ],
                "additionalProperties": false
              },
              "oldest": {
                "type": "object",
                "properties": {
                  "pressurehPa": {
                    "type": "number"
                  },
                  "timestampMs": {
                    "type": "number"
                  }
                },
                "required": [
                  "pressurehPa",
                  "timestampMs"
                ],
                "additionalProperties": false
              }
            },
            "required": [
              "latest",
              "oldest"
            ],
            "additionalProperties": false
          }
        },
        "required": [
          "pressureTrend",
          "forecast"
        ],
        "additionalProperties": false
      },
      "pressureHistory": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "timestamp": {
              "type": "number"
            },
            "averagePressurehPa": {
              "type": "number"
            }
          },
          "required": [
            "timestamp",
            "averagePressurehPa"
          ],
          "additionalProperties": false
        }
      }
    },
    "required": [
      "forecast",
      "pressureHistory"
    ],
    "additionalProperties": false
  },
  "homeTracker_histogramData_Input": {
    "type": "object",
    "required": [
      "timeWindow"
    ],
    "additionalProperties": false,
    "properties": {
      "timeWindow": {
        "type": "string",
        "enum": [
          "30m",
          "3h",
          "12h",
          "1d",
          "3d",
          "7d",
          "2w",
          "1M",
          "2M",
          "6M",
          "alltime"
        ]
      }
    }
  },
  "homeTracker_histogramData_Output": {
    "type": "object",
    "properties": {
      "sensorNames": {
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "histogramData": {
        "type": "object",
        "additionalProperties": {
          "type": "object",
          "properties": {
            "tempCelsius": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "internalTempCelsius": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "batteryCharge": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "humidity": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "internalHumidity": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "pressurehPa": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            }
          },
          "additionalProperties": false
        }
      }
    },
    "required": [
      "sensorNames",
      "histogramData"
    ],
    "additionalProperties": false
  },
  "homeTracker_histogramDataPublic_Input": {
    "type": "object",
    "required": [
      "timeWindow"
    ],
    "additionalProperties": false,
    "properties": {
      "timeWindow": {
        "type": "string",
        "enum": [
          "30m",
          "3h",
          "12h",
          "1d",
          "3d",
          "7d",
          "2w"
        ]
      }
    }
  },
  "homeTracker_histogramDataPublic_Output": {
    "type": "object",
    "properties": {
      "sensorNames": {
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "histogramData": {
        "type": "object",
        "additionalProperties": {
          "type": "object",
          "properties": {
            "tempCelsius": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "internalTempCelsius": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "batteryCharge": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "humidity": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "internalHumidity": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            },
            "pressurehPa": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            }
          },
          "additionalProperties": false
        }
      }
    },
    "required": [
      "sensorNames",
      "histogramData"
    ],
    "additionalProperties": false
  },
  "homeTracker_updateSensorMetadata_Input": {
    "type": "object",
    "required": [
      "sensorName",
      "hexColor",
      "tempOffset",
      "sleepTimeSec"
    ],
    "additionalProperties": false,
    "properties": {
      "sensorName": {
        "type": "string"
      },
      "hexColor": {
        "type": "string"
      },
      "tempOffset": {
        "type": "number"
      },
      "sleepTimeSec": {
        "type": "number",
        "minimum": 0
      }
    }
  },
  "homeTracker_updateSensorMetadata_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "homeTracker_upload_Input": {
    "type": "object",
    "required": [
      "sensorName"
    ],
    "additionalProperties": false,
    "properties": {
      "sensorName": {
        "description": "Name of the sensor",
        "type": "string"
      },
      "tempCelsius": {
        "description": "The current room temperature in celsius",
        "type": "number"
      },
      "humidity": {
        "description": "The current room humidity in percent",
        "type": "number"
      },
      "pressurePa": {
        "description": "The current room pressure in Pascal",
        "type": "number"
      },
      "internalTempCelsius": {
        "description": "The current room temperature in celsius",
        "type": "number"
      },
      "internalHumidity": {
        "description": "The current room humidity in percent",
        "type": "number"
      },
      "batteryCharge": {
        "description": "Computed charge of the battery in Volts",
        "type": "number"
      },
      "batteryPercent": {
        "description": "Computed percentage battery",
        "type": "number"
      },
      "timeToSendMs": {
        "description": "Computed interval between the start of the loop and the HTTP call",
        "type": "number"
      },
      "detectedLowBattery": {
        "description": "True if board detected a battery voltage low enough to trigger shutdown",
        "type": "boolean"
      },
      "detectedForcedReset": {
        "description": "True if board detected it restarted after an interrupt forced a restart",
        "type": "boolean"
      },
      "detectedInternalSensorFailure": {
        "description": "True if board detected it could not succcessfully read from the internal sensor",
        "type": "boolean"
      },
      "detectedSensorFailure": {
        "description": "True if board detected it could not succcessfully read from the main sensor",
        "type": "boolean"
      }
    }
  },
  "homeTracker_upload_Output": {
    "type": "object",
    "required": [
      "instructSleepSec"
    ],
    "additionalProperties": false,
    "properties": {
      "instructSleepSec": {
        "description": "The recommended sleeping time of the sensor in seconds",
        "type": "number"
      }
    }
  },
  "openapi_definitionJson_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "personalTracker_getAll_Output": {
    "type": "object",
    "required": [
      "events"
    ],
    "additionalProperties": false,
    "properties": {
      "events": {
        "type": "array",
        "minItems": 0,
        "items": {
          "type": "object",
          "required": [
            "eventDateUnix",
            "type",
            "value"
          ],
          "additionalProperties": false,
          "properties": {
            "eventDateUnix": {
              "description": "The date of the event in seconds in UTC",
              "type": "number"
            },
            "type": {
              "description": "Event type",
              "type": "string"
            },
            "value": {
              "description": "The value associated with the event",
              "type": "number"
            }
          }
        }
      }
    }
  },
  "personalTracker_upload_Input": {
    "type": "object",
    "required": [
      "event"
    ],
    "additionalProperties": false,
    "properties": {
      "event": {
        "type": "object",
        "required": [
          "timestampUTC",
          "type",
          "value"
        ],
        "additionalProperties": false,
        "properties": {
          "timestampUTC": {
            "description": "The date of the event in seconds in UTC",
            "type": "number"
          },
          "type": {
            "description": "Event type",
            "type": "string"
          },
          "value": {
            "description": "The value associated with the event",
            "type": "number"
          }
        }
      }
    }
  },
  "personalTracker_upload_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "reactor_addEntry_Input": {
    "type": "object",
    "required": [
      "name",
      "commaSeparatedTags",
      "file"
    ],
    "additionalProperties": false,
    "properties": {
      "name": {
        "type": "string"
      },
      "commaSeparatedTags": {
        "type": "string"
      },
      "file": {
        "type": "array"
      }
    }
  },
  "reactor_addEntry_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "reactor_getEntriesForPublic_Output": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "creationDateUnix": {
          "type": "number"
        },
        "s3PresignedUrl": {
          "type": "string"
        },
        "uri": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "name",
        "creationDateUnix",
        "s3PresignedUrl",
        "uri",
        "tags"
      ],
      "additionalProperties": false
    }
  },
  "misc_r_Output": {
    "type": "string",
    "description": "A S3 presigned URL to redirect to"
  },
  "webWatcher_createWatcher_Input": {
    "oneOf": [
      {
        "type": "object",
        "required": [
          "name",
          "notificationMessage",
          "url",
          "watchType",
          "cssSelector",
          "checkIntervalSeconds"
        ],
        "additionalProperties": false,
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the watcher (must be uniq)"
          },
          "notificationMessage": {
            "type": "string",
            "description": "Message to send went the content changes"
          },
          "url": {
            "type": "string",
            "description": "URL to monitor"
          },
          "watchType": {
            "type": "string",
            "description": "Type of watch to do",
            "enum": [
              "CSS"
            ]
          },
          "cssSelector": {
            "type": "string",
            "description": "CSS selector to the element to monitor in the page"
          },
          "checkIntervalSeconds": {
            "type": "number",
            "description": "Minimum time between to checks in seconds",
            "minimum": 900
          }
        }
      },
      {
        "type": "object",
        "required": [
          "name",
          "notificationMessage",
          "url",
          "watchType",
          "checkIntervalSeconds"
        ],
        "additionalProperties": false,
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the watcher (must be uniq)"
          },
          "notificationMessage": {
            "type": "string",
            "description": "Message to send went the content changes"
          },
          "url": {
            "type": "string",
            "description": "URL to monitor"
          },
          "watchType": {
            "type": "string",
            "description": "Type of watch to do",
            "enum": [
              "HASH"
            ]
          },
          "checkIntervalSeconds": {
            "type": "number",
            "description": "Minimum time between to checks in seconds",
            "minimum": 900
          }
        }
      }
    ]
  },
  "webWatcher_createWatcher_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "webWatcher_deleteWatcher_Input": {
    "type": "object",
    "required": [
      "id"
    ],
    "additionalProperties": false,
    "properties": {
      "id": {
        "type": "number",
        "description": "id of the watcher to delete"
      }
    }
  },
  "webWatcher_deleteWatcher_Output": {
    "type": "object",
    "additionalProperties": false
  },
  "webWatcher_getAllWatchers_Output": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "id": {
          "type": "number"
        },
        "name": {
          "type": "string"
        },
        "notificationMessage": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "watchType": {
          "type": "string",
          "enum": [
            "CSS",
            "HASH"
          ]
        },
        "cssSelector": {
          "type": "string"
        },
        "lastContent": {
          "type": "string"
        },
        "lastCheckDateUnix": {
          "type": [
            "number",
            "null"
          ]
        },
        "lastUpdateDateUnix": {
          "type": [
            "number",
            "null"
          ]
        },
        "archivalDateUnix": {
          "type": [
            "number",
            "null"
          ]
        },
        "checkIntervalSeconds": {
          "type": "number"
        },
        "lastErrorDateUnix": {
          "type": [
            "number",
            "null"
          ]
        },
        "lastErrorMessage": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "id",
        "name",
        "notificationMessage",
        "url",
        "watchType",
        "lastContent",
        "lastCheckDateUnix",
        "lastUpdateDateUnix",
        "archivalDateUnix",
        "checkIntervalSeconds",
        "lastErrorDateUnix",
        "lastErrorMessage"
      ],
      "additionalProperties": false
    }
  },
  "webWatcher_toggleWatcherEnabled_Input": {
    "type": "object",
    "required": [
      "watcherId",
      "setToEnabled"
    ],
    "additionalProperties": false,
    "properties": {
      "watcherId": {
        "type": "number",
        "description": "The sql id of the watcher"
      },
      "setToEnabled": {
        "type": "boolean",
        "description": "The new enabled status of the watcher"
      }
    }
  },
  "webWatcher_toggleWatcherEnabled_Output": {
    "type": "object",
    "additionalProperties": false
  }
} as const;

// AJV setup
const ajv = new Ajv();
const validators: Map<string, ValidateFunction> = new Map();

function getValidator(schema: any, key: string): ValidateFunction {
    if (!validators.has(key)) {
        validators.set(key, ajv.compile(schema));
    }
    return validators.get(key)!;
}

function validateInput(schema: any, data: unknown, endpoint: string): void {
    const validator = getValidator(schema, `input_${endpoint}`);
    if (!validator(data)) {
        throw new Error(`Invalid input for ${endpoint}: ${ajv.errorsText(validator.errors)}`);
    }
}

function validateOutput(schema: any, data: unknown, endpoint: string): void {
    const validator = getValidator(schema, `output_${endpoint}`);
    if (!validator(data)) {
        console.warn(`Invalid output for ${endpoint}: ${ajv.errorsText(validator.errors)}`);
    }
}

// API Client
export interface APIClientConfig {
    baseURL: string;
    credentials?: RequestCredentials;
    onError?: (error: Error, endpoint: string) => void;
}

export class APIClient {
    private baseURL: string;
    private credentials: RequestCredentials;
    private onError?: (error: Error, endpoint: string) => void;

    constructor(config: APIClientConfig) {
        this.baseURL = config.baseURL.replace(/\/$/, ''); // Remove trailing slash
        this.credentials = config.credentials || 'include';
        this.onError = config.onError;
    }

    private async fetch(path: string, options: RequestInit = {}): Promise<Response> {
        const url = `${this.baseURL}${path}`;

        try {
            const response = await fetch(url, {
                ...options,
                mode: 'cors',
                credentials: this.credentials
            });

            if (!response.ok) {
                const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
                this.onError?.(error, path);
                throw error;
            }

            return response;
        } catch (error) {
            const err = error instanceof Error ? error : new Error(String(error));
            this.onError?.(err, path);
            throw err;
        }
    }

  auth = {
    /**
     * POST /auth/login
     * Authentication: user2
     */
    login: async (input: FromSchema<typeof schemas.auth_login_Input>): Promise<FromSchema<typeof schemas.auth_login_Output>> => {
        validateInput(schemas.auth_login_Input, input, 'auth.login');

        const path = '/auth/login';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.auth_login_Output, output, 'auth.login');
        return output as FromSchema<typeof schemas.auth_login_Output>;
    },

    /**
     * POST /auth/logout
     * Authentication: user2
     */
    logout: async (input: FromSchema<typeof schemas.auth_logout_Input>): Promise<FromSchema<typeof schemas.auth_logout_Output>> => {
        validateInput(schemas.auth_logout_Input, input, 'auth.logout');

        const path = '/auth/logout';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.auth_logout_Output, output, 'auth.logout');
        return output as FromSchema<typeof schemas.auth_logout_Output>;
    },

    /**
     * POST /auth/me
     * Authentication: user2
     */
    me: async (input: FromSchema<typeof schemas.auth_me_Input>): Promise<FromSchema<typeof schemas.auth_me_Output>> => {
        validateInput(schemas.auth_me_Input, input, 'auth.me');

        const path = '/auth/me';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.auth_me_Output, output, 'auth.me');
        return output as FromSchema<typeof schemas.auth_me_Output>;
    }
  };

  chords = {
    /**
     * POST /chords/addLinkVisit
     * Authentication: user2
     */
    addLinkVisit: async (input: FromSchema<typeof schemas.chords_addLinkVisit_Input>): Promise<FromSchema<typeof schemas.chords_addLinkVisit_Output>> => {
        validateInput(schemas.chords_addLinkVisit_Input, input, 'chords.addLinkVisit');

        const path = '/chords/addLinkVisit';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.chords_addLinkVisit_Output, output, 'chords.addLinkVisit');
        return output as FromSchema<typeof schemas.chords_addLinkVisit_Output>;
    },

    /**
     * GET /chords/checkLinks
     * Authentication: none
     */
    checkLinks: async (): Promise<FromSchema<typeof schemas.chords_checkLinks_Output>> => {
        

        const path = '/chords/checkLinks';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.chords_checkLinks_Output, output, 'chords.checkLinks');
        return output as FromSchema<typeof schemas.chords_checkLinks_Output>;
    },

    /**
     * GET /chords/getAll
     * Authentication: none
     */
    getAll: async (): Promise<FromSchema<typeof schemas.chords_getAll_Output>> => {
        

        const path = '/chords/getAll';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.chords_getAll_Output, output, 'chords.getAll');
        return output as FromSchema<typeof schemas.chords_getAll_Output>;
    },

    /**
     * GET /chords/getLinksVisitsCount
     * Authentication: none
     */
    getLinksVisitsCount: async (): Promise<FromSchema<typeof schemas.chords_getLinksVisitsCount_Output>> => {
        

        const path = '/chords/getLinksVisitsCount';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.chords_getLinksVisitsCount_Output, output, 'chords.getLinksVisitsCount');
        return output as FromSchema<typeof schemas.chords_getLinksVisitsCount_Output>;
    },

    /**
     * POST /chords/updateAll
     * Authentication: user2
     */
    updateAll: async (input: FromSchema<typeof schemas.chords_updateAll_Input>): Promise<FromSchema<typeof schemas.chords_updateAll_Output>> => {
        validateInput(schemas.chords_updateAll_Input, input, 'chords.updateAll');

        const path = '/chords/updateAll';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.chords_updateAll_Output, output, 'chords.updateAll');
        return output as FromSchema<typeof schemas.chords_updateAll_Output>;
    }
  };

  clipboard = {
    /**
     * POST /clipboard/addEntry
     * Authentication: user2
     */
    addEntry: async (input: FromSchema<typeof schemas.clipboard_addEntry_Input>): Promise<FromSchema<typeof schemas.clipboard_addEntry_Output>> => {
        validateInput(schemas.clipboard_addEntry_Input, input, 'clipboard.addEntry');

        const path = '/clipboard/addEntry';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.clipboard_addEntry_Output, output, 'clipboard.addEntry');
        return output as FromSchema<typeof schemas.clipboard_addEntry_Output>;
    },

    /**
     * POST /clipboard/deleteEntry
     * Authentication: user2
     */
    deleteEntry: async (input: FromSchema<typeof schemas.clipboard_deleteEntry_Input>): Promise<FromSchema<typeof schemas.clipboard_deleteEntry_Output>> => {
        validateInput(schemas.clipboard_deleteEntry_Input, input, 'clipboard.deleteEntry');

        const path = '/clipboard/deleteEntry';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.clipboard_deleteEntry_Output, output, 'clipboard.deleteEntry');
        return output as FromSchema<typeof schemas.clipboard_deleteEntry_Output>;
    },

    /**
     * GET /clipboard/getAllEntries
     * Authentication: user2
     */
    getAllEntries: async (): Promise<FromSchema<typeof schemas.clipboard_getAllEntries_Output>> => {
        

        const path = '/clipboard/getAllEntries';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.clipboard_getAllEntries_Output, output, 'clipboard.getAllEntries');
        return output as FromSchema<typeof schemas.clipboard_getAllEntries_Output>;
    },

    /**
     * GET /clipboard/getPublicEntries
     * Authentication: none
     */
    getPublicEntries: async (): Promise<FromSchema<typeof schemas.clipboard_getPublicEntries_Output>> => {
        

        const path = '/clipboard/getPublicEntries';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.clipboard_getPublicEntries_Output, output, 'clipboard.getPublicEntries');
        return output as FromSchema<typeof schemas.clipboard_getPublicEntries_Output>;
    },

    /**
     * GET /clipboard/view
     * Authentication: none
     */
    view: async (): Promise<FromSchema<typeof schemas.clipboard_view_Output>> => {
        

        const path = '/clipboard/view';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.clipboard_view_Output, output, 'clipboard.view');
        return output as FromSchema<typeof schemas.clipboard_view_Output>;
    }
  };

  cookbook = {
    /**
     * POST /cookbook/addRecipe
     * Authentication: user2
     */
    addRecipe: async (input: FromSchema<typeof schemas.cookbook_addRecipe_Input>): Promise<FromSchema<typeof schemas.cookbook_addRecipe_Output>> => {
        validateInput(schemas.cookbook_addRecipe_Input, input, 'cookbook.addRecipe');

        const path = '/cookbook/addRecipe';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.cookbook_addRecipe_Output, output, 'cookbook.addRecipe');
        return output as FromSchema<typeof schemas.cookbook_addRecipe_Output>;
    },

    /**
     * POST /cookbook/getRecipe
     * Authentication: user2
     */
    getRecipe: async (input: FromSchema<typeof schemas.cookbook_getRecipe_Input>): Promise<FromSchema<typeof schemas.cookbook_getRecipe_Output>> => {
        validateInput(schemas.cookbook_getRecipe_Input, input, 'cookbook.getRecipe');

        const path = '/cookbook/getRecipe';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.cookbook_getRecipe_Output, output, 'cookbook.getRecipe');
        return output as FromSchema<typeof schemas.cookbook_getRecipe_Output>;
    },

    /**
     * GET /cookbook/listIngredients
     * Authentication: user2
     */
    listIngredients: async (): Promise<FromSchema<typeof schemas.cookbook_listIngredients_Output>> => {
        

        const path = '/cookbook/listIngredients';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.cookbook_listIngredients_Output, output, 'cookbook.listIngredients');
        return output as FromSchema<typeof schemas.cookbook_listIngredients_Output>;
    },

    /**
     * GET /cookbook/listRecipes
     * Authentication: user2
     */
    listRecipes: async (): Promise<FromSchema<typeof schemas.cookbook_listRecipes_Output>> => {
        

        const path = '/cookbook/listRecipes';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.cookbook_listRecipes_Output, output, 'cookbook.listRecipes');
        return output as FromSchema<typeof schemas.cookbook_listRecipes_Output>;
    }
  };

  gravitrips = {
    /**
     * GET /gravitrips/getNewGame
     * Authentication: none
     */
    getNewGame: async (): Promise<FromSchema<typeof schemas.gravitrips_getNewGame_Output>> => {
        

        const path = '/gravitrips/getNewGame';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.gravitrips_getNewGame_Output, output, 'gravitrips.getNewGame');
        return output as FromSchema<typeof schemas.gravitrips_getNewGame_Output>;
    }
  };

  health = {
    /**
     * GET /health/getRemoteTime
     * Authentication: none
     */
    getRemoteTime: async (): Promise<FromSchema<typeof schemas.health_getRemoteTime_Output>> => {
        

        const path = '/health/getRemoteTime';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.health_getRemoteTime_Output, output, 'health.getRemoteTime');
        return output as FromSchema<typeof schemas.health_getRemoteTime_Output>;
    }
  };

  homeTracker = {
    /**
     * GET /homeTracker/getEphemerides
     * Authentication: none
     */
    getEphemerides: async (): Promise<FromSchema<typeof schemas.homeTracker_getEphemerides_Output>> => {
        

        const path = '/homeTracker/getEphemerides';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.homeTracker_getEphemerides_Output, output, 'homeTracker.getEphemerides');
        return output as FromSchema<typeof schemas.homeTracker_getEphemerides_Output>;
    },

    /**
     * GET /homeTracker/getSensorsDataForDashboard
     * Authentication: none
     */
    getSensorsDataForDashboard: async (): Promise<FromSchema<typeof schemas.homeTracker_getSensorsDataForDashboard_Output>> => {
        

        const path = '/homeTracker/getSensorsDataForDashboard';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.homeTracker_getSensorsDataForDashboard_Output, output, 'homeTracker.getSensorsDataForDashboard');
        return output as FromSchema<typeof schemas.homeTracker_getSensorsDataForDashboard_Output>;
    },

    /**
     * GET /homeTracker/getWeatherForecast
     * Authentication: none
     */
    getWeatherForecast: async (): Promise<FromSchema<typeof schemas.homeTracker_getWeatherForecast_Output>> => {
        

        const path = '/homeTracker/getWeatherForecast';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.homeTracker_getWeatherForecast_Output, output, 'homeTracker.getWeatherForecast');
        return output as FromSchema<typeof schemas.homeTracker_getWeatherForecast_Output>;
    },

    /**
     * POST /homeTracker/histogramData
     * Authentication: user2
     */
    histogramData: async (input: FromSchema<typeof schemas.homeTracker_histogramData_Input>): Promise<FromSchema<typeof schemas.homeTracker_histogramData_Output>> => {
        validateInput(schemas.homeTracker_histogramData_Input, input, 'homeTracker.histogramData');

        const path = '/homeTracker/histogramData';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.homeTracker_histogramData_Output, output, 'homeTracker.histogramData');
        return output as FromSchema<typeof schemas.homeTracker_histogramData_Output>;
    },

    /**
     * POST /homeTracker/histogramDataPublic
     * Authentication: none
     */
    histogramDataPublic: async (input: FromSchema<typeof schemas.homeTracker_histogramDataPublic_Input>): Promise<FromSchema<typeof schemas.homeTracker_histogramDataPublic_Output>> => {
        validateInput(schemas.homeTracker_histogramDataPublic_Input, input, 'homeTracker.histogramDataPublic');

        const path = '/homeTracker/histogramDataPublic';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.homeTracker_histogramDataPublic_Output, output, 'homeTracker.histogramDataPublic');
        return output as FromSchema<typeof schemas.homeTracker_histogramDataPublic_Output>;
    },

    /**
     * POST /homeTracker/updateSensorMetadata
     * Authentication: user2
     */
    updateSensorMetadata: async (input: FromSchema<typeof schemas.homeTracker_updateSensorMetadata_Input>): Promise<FromSchema<typeof schemas.homeTracker_updateSensorMetadata_Output>> => {
        validateInput(schemas.homeTracker_updateSensorMetadata_Input, input, 'homeTracker.updateSensorMetadata');

        const path = '/homeTracker/updateSensorMetadata';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.homeTracker_updateSensorMetadata_Output, output, 'homeTracker.updateSensorMetadata');
        return output as FromSchema<typeof schemas.homeTracker_updateSensorMetadata_Output>;
    },

    /**
     * POST /homeTracker/upload
     * Authentication: apikey-iot
     */
    upload: async (input: FromSchema<typeof schemas.homeTracker_upload_Input>): Promise<FromSchema<typeof schemas.homeTracker_upload_Output>> => {
        validateInput(schemas.homeTracker_upload_Input, input, 'homeTracker.upload');

        const path = '/homeTracker/upload';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.homeTracker_upload_Output, output, 'homeTracker.upload');
        return output as FromSchema<typeof schemas.homeTracker_upload_Output>;
    }
  };

  openapi = {
    /**
     * GET /openapi/definition.json
     * Authentication: none
     */
    definitionJson: async (): Promise<FromSchema<typeof schemas.openapi_definitionJson_Output>> => {
        

        const path = '/openapi/definition.json';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.openapi_definitionJson_Output, output, 'openapi.definitionJson');
        return output as FromSchema<typeof schemas.openapi_definitionJson_Output>;
    }
  };

  personalTracker = {
    /**
     * GET /personalTracker/getAll
     * Authentication: user2
     */
    getAll: async (): Promise<FromSchema<typeof schemas.personalTracker_getAll_Output>> => {
        

        const path = '/personalTracker/getAll';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.personalTracker_getAll_Output, output, 'personalTracker.getAll');
        return output as FromSchema<typeof schemas.personalTracker_getAll_Output>;
    },

    /**
     * POST /personalTracker/upload
     * Authentication: user2
     */
    upload: async (input: FromSchema<typeof schemas.personalTracker_upload_Input>): Promise<FromSchema<typeof schemas.personalTracker_upload_Output>> => {
        validateInput(schemas.personalTracker_upload_Input, input, 'personalTracker.upload');

        const path = '/personalTracker/upload';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.personalTracker_upload_Output, output, 'personalTracker.upload');
        return output as FromSchema<typeof schemas.personalTracker_upload_Output>;
    }
  };

  reactor = {
    /**
     * POST /reactor/addEntry
     * Authentication: user2
     */
    addEntry: async (input: FromSchema<typeof schemas.reactor_addEntry_Input>): Promise<FromSchema<typeof schemas.reactor_addEntry_Output>> => {
        validateInput(schemas.reactor_addEntry_Input, input, 'reactor.addEntry');

        const path = '/reactor/addEntry';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.reactor_addEntry_Output, output, 'reactor.addEntry');
        return output as FromSchema<typeof schemas.reactor_addEntry_Output>;
    },

    /**
     * GET /reactor/getEntriesForPublic
     * Authentication: none
     */
    getEntriesForPublic: async (): Promise<FromSchema<typeof schemas.reactor_getEntriesForPublic_Output>> => {
        

        const path = '/reactor/getEntriesForPublic';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.reactor_getEntriesForPublic_Output, output, 'reactor.getEntriesForPublic');
        return output as FromSchema<typeof schemas.reactor_getEntriesForPublic_Output>;
    }
  };

  misc = {
    /**
     * GET /r/:linkId
     * Authentication: none
     */
    r: async (params: { linkId: string }): Promise<FromSchema<typeof schemas.misc_r_Output>> => {
        

        const path = '/r/:linkId'.replace(':linkId', params.linkId);;

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.misc_r_Output, output, 'misc.r');
        return output as FromSchema<typeof schemas.misc_r_Output>;
    }
  };

  webWatcher = {
    /**
     * POST /webWatcher/createWatcher
     * Authentication: user2
     */
    createWatcher: async (input: FromSchema<typeof schemas.webWatcher_createWatcher_Input>): Promise<FromSchema<typeof schemas.webWatcher_createWatcher_Output>> => {
        validateInput(schemas.webWatcher_createWatcher_Input, input, 'webWatcher.createWatcher');

        const path = '/webWatcher/createWatcher';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.webWatcher_createWatcher_Output, output, 'webWatcher.createWatcher');
        return output as FromSchema<typeof schemas.webWatcher_createWatcher_Output>;
    },

    /**
     * POST /webWatcher/deleteWatcher
     * Authentication: user2
     */
    deleteWatcher: async (input: FromSchema<typeof schemas.webWatcher_deleteWatcher_Input>): Promise<FromSchema<typeof schemas.webWatcher_deleteWatcher_Output>> => {
        validateInput(schemas.webWatcher_deleteWatcher_Input, input, 'webWatcher.deleteWatcher');

        const path = '/webWatcher/deleteWatcher';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.webWatcher_deleteWatcher_Output, output, 'webWatcher.deleteWatcher');
        return output as FromSchema<typeof schemas.webWatcher_deleteWatcher_Output>;
    },

    /**
     * GET /webWatcher/getAllWatchers
     * Authentication: none
     */
    getAllWatchers: async (): Promise<FromSchema<typeof schemas.webWatcher_getAllWatchers_Output>> => {
        

        const path = '/webWatcher/getAllWatchers';

        const response = await this.fetch(
            path,
            { method: 'GET' }
        );

        const output = await response.json();
        validateOutput(schemas.webWatcher_getAllWatchers_Output, output, 'webWatcher.getAllWatchers');
        return output as FromSchema<typeof schemas.webWatcher_getAllWatchers_Output>;
    },

    /**
     * POST /webWatcher/toggleWatcherEnabled
     * Authentication: user2
     */
    toggleWatcherEnabled: async (input: FromSchema<typeof schemas.webWatcher_toggleWatcherEnabled_Input>): Promise<FromSchema<typeof schemas.webWatcher_toggleWatcherEnabled_Output>> => {
        validateInput(schemas.webWatcher_toggleWatcherEnabled_Input, input, 'webWatcher.toggleWatcherEnabled');

        const path = '/webWatcher/toggleWatcherEnabled';

        const response = await this.fetch(
            path,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            }
        );

        const output = await response.json();
        validateOutput(schemas.webWatcher_toggleWatcherEnabled_Output, output, 'webWatcher.toggleWatcherEnabled');
        return output as FromSchema<typeof schemas.webWatcher_toggleWatcherEnabled_Output>;
    }
  };
}

// Type exports for convenience
export type Auth_Login_Input = FromSchema<typeof schemas.auth_login_Input>;
export type Auth_Login_Output = FromSchema<typeof schemas.auth_login_Output>;
export type Auth_Logout_Input = FromSchema<typeof schemas.auth_logout_Input>;
export type Auth_Logout_Output = FromSchema<typeof schemas.auth_logout_Output>;
export type Auth_Me_Input = FromSchema<typeof schemas.auth_me_Input>;
export type Auth_Me_Output = FromSchema<typeof schemas.auth_me_Output>;
export type Chords_AddLinkVisit_Input = FromSchema<typeof schemas.chords_addLinkVisit_Input>;
export type Chords_AddLinkVisit_Output = FromSchema<typeof schemas.chords_addLinkVisit_Output>;
export type Chords_CheckLinks_Output = FromSchema<typeof schemas.chords_checkLinks_Output>;
export type Chords_GetAll_Output = FromSchema<typeof schemas.chords_getAll_Output>;
export type Chords_GetLinksVisitsCount_Output = FromSchema<typeof schemas.chords_getLinksVisitsCount_Output>;
export type Chords_UpdateAll_Input = FromSchema<typeof schemas.chords_updateAll_Input>;
export type Chords_UpdateAll_Output = FromSchema<typeof schemas.chords_updateAll_Output>;
export type Clipboard_AddEntry_Input = FromSchema<typeof schemas.clipboard_addEntry_Input>;
export type Clipboard_AddEntry_Output = FromSchema<typeof schemas.clipboard_addEntry_Output>;
export type Clipboard_DeleteEntry_Input = FromSchema<typeof schemas.clipboard_deleteEntry_Input>;
export type Clipboard_DeleteEntry_Output = FromSchema<typeof schemas.clipboard_deleteEntry_Output>;
export type Clipboard_GetAllEntries_Output = FromSchema<typeof schemas.clipboard_getAllEntries_Output>;
export type Clipboard_GetPublicEntries_Output = FromSchema<typeof schemas.clipboard_getPublicEntries_Output>;
export type Clipboard_View_Output = FromSchema<typeof schemas.clipboard_view_Output>;
export type Cookbook_AddRecipe_Input = FromSchema<typeof schemas.cookbook_addRecipe_Input>;
export type Cookbook_AddRecipe_Output = FromSchema<typeof schemas.cookbook_addRecipe_Output>;
export type Cookbook_GetRecipe_Input = FromSchema<typeof schemas.cookbook_getRecipe_Input>;
export type Cookbook_GetRecipe_Output = FromSchema<typeof schemas.cookbook_getRecipe_Output>;
export type Cookbook_ListIngredients_Output = FromSchema<typeof schemas.cookbook_listIngredients_Output>;
export type Cookbook_ListRecipes_Output = FromSchema<typeof schemas.cookbook_listRecipes_Output>;
export type Gravitrips_GetNewGame_Output = FromSchema<typeof schemas.gravitrips_getNewGame_Output>;
export type Health_GetRemoteTime_Output = FromSchema<typeof schemas.health_getRemoteTime_Output>;
export type HomeTracker_GetEphemerides_Output = FromSchema<typeof schemas.homeTracker_getEphemerides_Output>;
export type HomeTracker_GetSensorsDataForDashboard_Output = FromSchema<typeof schemas.homeTracker_getSensorsDataForDashboard_Output>;
export type HomeTracker_GetWeatherForecast_Output = FromSchema<typeof schemas.homeTracker_getWeatherForecast_Output>;
export type HomeTracker_HistogramData_Input = FromSchema<typeof schemas.homeTracker_histogramData_Input>;
export type HomeTracker_HistogramData_Output = FromSchema<typeof schemas.homeTracker_histogramData_Output>;
export type HomeTracker_HistogramDataPublic_Input = FromSchema<typeof schemas.homeTracker_histogramDataPublic_Input>;
export type HomeTracker_HistogramDataPublic_Output = FromSchema<typeof schemas.homeTracker_histogramDataPublic_Output>;
export type HomeTracker_UpdateSensorMetadata_Input = FromSchema<typeof schemas.homeTracker_updateSensorMetadata_Input>;
export type HomeTracker_UpdateSensorMetadata_Output = FromSchema<typeof schemas.homeTracker_updateSensorMetadata_Output>;
export type HomeTracker_Upload_Input = FromSchema<typeof schemas.homeTracker_upload_Input>;
export type HomeTracker_Upload_Output = FromSchema<typeof schemas.homeTracker_upload_Output>;
export type Openapi_DefinitionJson_Output = FromSchema<typeof schemas.openapi_definitionJson_Output>;
export type PersonalTracker_GetAll_Output = FromSchema<typeof schemas.personalTracker_getAll_Output>;
export type PersonalTracker_Upload_Input = FromSchema<typeof schemas.personalTracker_upload_Input>;
export type PersonalTracker_Upload_Output = FromSchema<typeof schemas.personalTracker_upload_Output>;
export type Reactor_AddEntry_Input = FromSchema<typeof schemas.reactor_addEntry_Input>;
export type Reactor_AddEntry_Output = FromSchema<typeof schemas.reactor_addEntry_Output>;
export type Reactor_GetEntriesForPublic_Output = FromSchema<typeof schemas.reactor_getEntriesForPublic_Output>;
export type Misc_R_Output = FromSchema<typeof schemas.misc_r_Output>;
export type WebWatcher_CreateWatcher_Input = FromSchema<typeof schemas.webWatcher_createWatcher_Input>;
export type WebWatcher_CreateWatcher_Output = FromSchema<typeof schemas.webWatcher_createWatcher_Output>;
export type WebWatcher_DeleteWatcher_Input = FromSchema<typeof schemas.webWatcher_deleteWatcher_Input>;
export type WebWatcher_DeleteWatcher_Output = FromSchema<typeof schemas.webWatcher_deleteWatcher_Output>;
export type WebWatcher_GetAllWatchers_Output = FromSchema<typeof schemas.webWatcher_getAllWatchers_Output>;
export type WebWatcher_ToggleWatcherEnabled_Input = FromSchema<typeof schemas.webWatcher_toggleWatcherEnabled_Input>;
export type WebWatcher_ToggleWatcherEnabled_Output = FromSchema<typeof schemas.webWatcher_toggleWatcherEnabled_Output>;
